---
title: "Linear regression in R"
---

```{r message = F}
library(tidyverse)
library(openintro)
```

### `lm()` function

The function that will obtain the coefficients for the least-squares line is the `lm()` function. The syntax is as follows:

`lm(response ~ explanatory, data)`

### Example 1: `cherry` data with continuous $x$

Let's once again consider the `cherry` data from `openintro`, where we want to fit the model

$$\text{volume} = \beta_{0} + \beta_{1} \times \text{diameter} + \epsilon$$

What does this look like in `R`?

```{r eval = F}
lm(volume ~ diam, data = cherry)
```

*Note that the variables have to be spelled as they appear in the data frame!*

The output from this line of code is:

```{r echo = F}
lm(volume ~ diam, data = cherry)
```

This isn't the most informative of output, so what we will do is use an additional function called `summary()` that will give us much more information!

We will first store the output from `lm()` as a variable called `cherry_lm`:

```{r}
cherry_lm <- lm(volume ~ diam, data = cherry)
```

Then we will use the `summary()` function and pass in the linear model:

```{r}
summary(cherry_lm)
```

There's a lot more information here! We can now see the $b_{0}$ and $b_{1}$ estimates, along with some extra information. In particular, the "Multiple R-squared" quantity is the coefficient of determination $R^2$!

### Example 2: `possum` data with categorical $x$

The nice thing about `lm()` is that it will automatically convert categorical variables to indicator variables!

Let's re-visit the `possum` model:

$$\text{tail length} = \beta_{0} + \beta_{1} \times \text{pop-other} + \epsilon$$ $$
\text{pop-other} = \begin{cases}
0 & \text{ if  pop = Vic} \\
1 & \text{ if  pop = other}
\end{cases}
$$

We can use the `lm()` function just as before:

```{r}
possum_lm <- lm(tail_l ~ pop, data = possum)
```

Sometimes we just want the coefficients. The `coef()` function will output the coefficients as a vector. These can be nice for reproducibility and in-line code:

```{r}
coef(possum_lm)
```

## Pretty output using `broom`

The `broom` package has a function that turns the output from `lm()` into tidy, data frame form. We simply pass in the fitted model into the function of interest!

::: column-margin
Install the package either by typing `install.packages("broom")` in your Console, or in the Packages pane.
:::

### `tidy()`

The function `tidy()` turns the information about the coefficients into a nice data frame:

```{r}
library(broom)
tidy(cherry_lm)
```

Since this is in data frame, each column is a variable, and all of our `dplyr` wrangling functions work!

```{r}
tidy(cherry_lm) |>
  pull(estimate)
```

### `glance()`

The function `glance()` turns the extra information about the model fit into nice data frame:

```{r}
glance(cherry_lm)
glance(cherry_lm) |>
  pull(r.squared)
```

### `augment()`

The function `augment()` adds information about observations to the dataset:

```{r}
augment(cherry_lm) |>
  slice(1:3)
```

You can see the original `x` and `y` values (`diam` and `volume`), as well as:

-   `.fitted`: the fitted (estimated) values $\hat{y}$ for the corresponding observation

-   `.resid`: the residual for the observation (taken as $y - \hat{y}$...)

::: column-margin
The periods are important!
:::

We can use the output from augment to plot residuals:

```{r fig.height=3.5, fig.width=6}
augment(cherry_lm) |>
  ggplot(aes(x = diam, y = .resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed")
```
